/**
 * TypeDoc plugin to generate llms.txt files for LLM consumption
 *
 * @packageDocumentation
 */

import fs from 'node:fs';
import path from 'node:path';
import { type Application, RendererEvent } from 'typedoc';

import {
  autoGenerateDeclarations,
  discoverSections,
  getProjectDescription,
  getProjectName,
  type LlmsTxtContent,
  renderLlmsTxt,
  resolveDeclarations,
} from './generator.js';
import { declareOptions, getOptions } from './options.js';
import { applyTemplate, readTemplate, templateExists } from './template.js';

export {
  discoverSections,
  type DocumentInfo,
  extractFrontmatter,
  type LlmsTxtContent,
  renderLlmsTxt,
  type ResolvedDeclaration,
  type Section,
  stripYamlQuotes,
  titleToUrlPath,
} from './generator.js';
export { declareOptions, getOptions } from './options.js';
export type {
  LlmsTxtDeclaration,
  LlmsTxtHeader,
  LlmsTxtSectionConfig,
} from './options.js';
export { applyTemplate, findSlots, readTemplate } from './template.js';

/**
 * TypeDoc plugin entry point
 *
 * @function
 * @param app - TypeDoc application instance
 */
export const load = (app: Application): void => {
  // Register options
  declareOptions(app);

  // Hook into render end to generate llms.txt
  app.renderer.on(RendererEvent.END, (event) => {
    const options = getOptions(app);

    if (!options.enabled) {
      app.logger.info('[llms-txt] Generation disabled');
      return;
    }

    const project = event.project;
    const outputDir = app.options.getValue('out') as string;

    // Determine base URL
    const cname = app.options.getValue('cname') as string | undefined;
    const baseUrl = cname ? `https://${cname}` : '';

    // Get project documents for section discovery
    const projectDocuments =
      (app.options.getValue('projectDocuments') as string[] | undefined) ?? [];

    // Resolve project documents to actual file paths
    const resolvedDocPaths: string[] = [];

    /**
     * Recursively walks a directory and collects all .md files
     *
     * @function
     */
    const walkDir = (dir: string) => {
      try {
        for (const entry of fs.readdirSync(dir, { withFileTypes: true })) {
          const fullPath = path.join(dir, entry.name);
          if (entry.isDirectory()) {
            walkDir(fullPath);
          } else if (entry.isFile() && entry.name.endsWith('.md')) {
            resolvedDocPaths.push(fullPath);
          }
        }
      } catch {
        // Directory doesn't exist or can't be read
      }
    };

    /**
     * Resolves a glob pattern to a base directory path
     *
     * For example, `../site/**\/*.md` becomes `../site`
     *
     * @function
     */
    const getGlobBasePath = (pattern: string): string => {
      // Find the first path segment that contains a glob character
      const parts = pattern.split(path.sep);
      const baseParts: string[] = [];

      for (const part of parts) {
        if (part.includes('*') || part.includes('?') || part.includes('[')) {
          break;
        }
        baseParts.push(part);
      }

      return baseParts.join(path.sep) || '.';
    };

    for (const pattern of projectDocuments) {
      // Check if this is a glob pattern
      if (pattern.includes('*')) {
        // Resolve the base path and walk it
        const basePath = getGlobBasePath(pattern);
        if (fs.existsSync(basePath)) {
          const stat = fs.statSync(basePath);
          if (stat.isDirectory()) {
            walkDir(basePath);
          } else if (stat.isFile() && basePath.endsWith('.md')) {
            resolvedDocPaths.push(basePath);
          }
        }
      } else if (fs.existsSync(pattern)) {
        const stat = fs.statSync(pattern);
        if (stat.isFile()) {
          resolvedDocPaths.push(pattern);
        } else if (stat.isDirectory()) {
          walkDir(pattern);
        }
      }
    }

    // Build content
    const header = {
      description: getProjectDescription(app, options.header),
      features: options.header.features ?? [],
      name: getProjectName(app, options.header),
    };

    const sections = discoverSections(
      resolvedDocPaths,
      options.sections,
      baseUrl,
    );

    // Resolve or auto-generate declarations
    let declarations;
    if (options.declarations.length > 0) {
      declarations = resolveDeclarations(
        options.declarations,
        project,
        app,
        baseUrl,
      );
    } else {
      declarations = autoGenerateDeclarations(project, baseUrl);
    }

    const content: LlmsTxtContent = {
      declarations,
      header,
      quickReference: options.quickReference,
      sections,
    };

    // Render content
    let output: string;

    if (options.template && templateExists(options.template)) {
      // Use custom template
      const template = readTemplate(options.template);
      output = applyTemplate(template, content);
      app.logger.info(`[llms-txt] Using template: ${options.template}`);
    } else {
      // Use default rendering
      output = renderLlmsTxt(content);
    }

    // Write to output directory
    const outputPath = path.join(outputDir, options.filename);
    fs.writeFileSync(outputPath, output, 'utf8');
    app.logger.info(
      `[llms-txt] Generated ${path.relative(process.cwd(), outputPath)}`,
    );
  });
};
